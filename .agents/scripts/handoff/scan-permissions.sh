#!/bin/bash
# Scan agent worktrees for permission candidates — Generated by /handoff setup
# Usage: .agents/scripts/handoff/scan-permissions.sh
#
# Reads .agents/config.yml to discover agent worktrees.
# Scans each worktree's .claude/settings.local.json (skips if missing).
# Reads .claude/settings.json as the shared baseline.
# Normalizes malformed patterns, rejects absolute paths, skips baseline-covered entries.
# Outputs a JSON report to stdout.
#
# Exit codes:
#   0 — Scan complete (report on stdout)
#   1 — Missing config or settings file

set -e

# Resolve PROJECT_ROOT from primary git worktree
PROJECT_ROOT=$(git worktree list --porcelain | head -1 | sed 's/^worktree //')

CONFIG="$PROJECT_ROOT/.agents/config.yml"
SETTINGS="$PROJECT_ROOT/.claude/settings.json"

if [ ! -f "$CONFIG" ]; then
  echo "Cannot find .agents/config.yml" >&2
  exit 1
fi

if [ ! -f "$SETTINGS" ]; then
  echo "Cannot find .claude/settings.json" >&2
  exit 1
fi

# Read baseline permissions as JSON array
BASELINE_JSON=$(jq '.permissions.allow // []' "$SETTINGS")

# Extract worktree paths from config.yml
WORKTREES=()
while IFS= read -r line; do
  wt=$(echo "$line" | sed 's/.*worktree:[[:space:]]*//' | tr -d '"' | tr -d "'" | sed 's/[[:space:]]*$//')
  if [ -n "$wt" ]; then
    WORKTREES+=("$wt")
  fi
done < <(grep 'worktree:' "$CONFIG" 2>/dev/null || true)

# Collect entries into a temp file (NDJSON: one JSON object per line)
TMPFILE=$(mktemp)
trap 'rm -f "$TMPFILE"' EXIT

for wt_rel in "${WORKTREES[@]}"; do
  wt_path="$PROJECT_ROOT/$wt_rel"
  local_settings="$wt_path/.claude/settings.local.json"

  if [ ! -f "$local_settings" ]; then
    continue
  fi

  while IFS= read -r perm; do
    [ -z "$perm" ] && continue

    # Reject absolute paths (inside parens or standalone)
    if echo "$perm" | grep -qE '\(/'; then
      jq -nc --arg p "$perm" --arg r "absolute path" --arg w "$wt_rel" \
        '{"type":"rejected","pattern":$p,"reason":$r,"worktree":$w}' >> "$TMPFILE"
      continue
    fi

    # Check if already covered by baseline (exact match on original form)
    covered=$(jq -r --arg p "$perm" 'if any(. == $p) then "yes" else "no" end' <<< "$BASELINE_JSON")
    if [ "$covered" = "yes" ]; then
      continue
    fi

    # Normalize: fix missing space before *, fix stray : before *
    normalized=$(echo "$perm" | sed -E 's/([^[:space:]])\*/\1 */g; s/:[[:space:]]?\*/ */g')

    # Track malformed patterns (original differs from normalized)
    if [ "$normalized" != "$perm" ]; then
      jq -nc --arg o "$perm" --arg f "$normalized" --arg w "$wt_rel" \
        '{"type":"malformed","original":$o,"fixed":$f,"worktree":$w}' >> "$TMPFILE"
    fi

    # Emit candidate (using normalized pattern)
    jq -nc --arg p "$normalized" --arg w "$wt_rel" \
      '{"type":"candidate","pattern":$p,"worktree":$w}' >> "$TMPFILE"

  done < <(jq -r '.permissions.allow // [] | .[]' "$local_settings" 2>/dev/null)
done

# If no entries collected, output empty report
if [ ! -s "$TMPFILE" ]; then
  jq -n --argjson baseline "$BASELINE_JSON" \
    '{"baseline": $baseline, "candidates": [], "malformed": [], "rejected": []}'
  exit 0
fi

# Aggregate: group candidates by pattern, separate rejected and malformed
jq -s --argjson baseline "$BASELINE_JSON" '
  (map(select(.type == "rejected")) | map({pattern, reason, worktree})) as $rejected |
  (map(select(.type == "malformed")) | map({original, fixed, worktree})) as $malformed |
  (map(select(.type == "candidate")) | map({pattern, worktree})) as $raw |
  ($raw | group_by(.pattern) | map({
    "pattern": .[0].pattern,
    "count": length,
    "worktrees": [.[].worktree]
  })) as $candidates |
  {
    "baseline": $baseline,
    "candidates": $candidates,
    "malformed": $malformed,
    "rejected": $rejected
  }
' "$TMPFILE"
